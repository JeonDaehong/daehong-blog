export const dbTechnologies = [
  {
    name: "💡 MySQL",
    description: "MySQL 관련 질문과 답변",
    category: "DB",
    details: [
      {
        title: "Q. MySQL 의 InnoDB 스토리지의 특징에 대해 설명하세요.",
        date: "2025.10.07",
        detail: `
          먼저 **MySQL**의 Storage Engine 에는 **InnoDB, MEMORY, MRG_MYISAM, CSV, PERFORMANCE_SCHEMA, MyISAM, BLACKHOLE, ARCHIVE, FEDERATED** 이렇게 9가지 스토리지 엔진이 있습니다.
          이 중, **InnoDB** 5.5 부터 기본 스토리지 엔진으로 사용되며, 지금까지 유용하게 사용되는 스토리지 엔진입니다.
          InnoDB는 DML 작업은 ACID 모델을 따르며 Commit, Rollback 및 복구 기능을 갖춘 트랜잭션으로 Data를 보호합니다. 또한 Oracle의 Buffer Cache와 마찬가지로 디스크 상의 Data 파일이나 인덱스 정보를 메모리에 캐시 해두기 위한 공간을 가지고 있어 변경된 Data를 모아서 처리하기 때문에 디스크 I/O 횟수를 줄일 수 있습니다.

          InnoDB의 개략적인 구조를 살펴보면, 여러 내부 컴포넌트가 협력하여 트랜잭션 무결성과 성능을 보장합니다. 이 아키텍처는 크게 InnoDB Buffer Pool (데이터와 인덱스를 메모리에 캐싱), Double Write Buffer(데이터 무결성 보장), Undo Log(트랜잭션 롤백 및 격리 수준 유지), Change Buffer(인덱스 비일관성 관리), Redo Log and Log Buffer(데이터 복구), Adaptive Hash Index 등 여러가지로 구성되어 있습니다. 각 구성 요소는 데이터를 안전하게 저장하고, 장애 시 자동으로 복구하며, 동시에 여러 트랜잭션을 처리할 수 있도록 설계되어 있습니다.

          InnoDB의 특징을 하나하나 보겠습니다. InnoDB의 가장 큰 특징 중 하나는 모든 테이블이 **프라이머리 키(Primary Key)**를 기준으로 클러스터링(Clustering) 되어 저장된다는 점입니다.
          즉, 프라이머리 키 값의 순서대로 실제 레코드가 디스크 상에 물리적으로 정렬되어 저장됩니다. 이러한 구조 덕분에 **프라이머리 키를 이용한 범위 검색(range scan)**이나 **순차적 접근(sequential I/O)**이 매우 빠르게 수행됩니다. 이는 데이터가 프라이머리 키 순서대로 정렬되어 있으므로, 필요한 데이터가 디스크의 인접한 페이지에 연속적으로 존재하기 때문입니다.

          InnoDB에서는 하나의 테이블이 오직 하나의 클러스터링 인덱스만을 가질 수 있습니다. 이는 데이터가 물리적으로 한 가지 순서(프라이머리 키 순서)로만 정렬되어 저장되기 때문입니다. 예를 들어 주문번호를 기준으로 클러스터링된 테이블에서 데이터를 고객 ID 순으로도 동시에 정렬할 수는 없습니다. 이 제약이 오히려 InnoDB의 강점으로 작용하여, 데이터를 한 방향으로 정렬하고 연속된 블록 단위로 효율적으로 읽어올 수 있게 해줍니다

          또한, InnoDB의 **세컨더리 인덱스(Secondary Index)**는 실제 데이터의 물리적 주소를 저장하지 않습니다. 대신, 세컨더리 인덱스의 리프 노드에는 해당 인덱스 키와 해당 레코드의 프라이머리 키 값이 저장됩니다. 즉, 세컨더리 인덱스를 통해 데이터를 찾을 때는 다음 두 단계를 거칩니다.
          1. - 세컨더리 인덱스에서 인덱스 키를 검색해 해당 레코드의 프라이머리 키 값을 찾는다.
          2. - 그 프라이머리 키 값을 이용해 클러스터링 인덱스를 다시 탐색하여 실제 데이터를 조회한다.
          이중 접근(double lookup) 과정은 MyISAM보다 느릴 수 있지만, InnoDB는 이를 통해 **데이터 일관성(consistency)**과 논리적 안정성을 확보합니다. 즉, 데이터가 물리적으로 이동하거나 페이지가 분할되더라도 세컨더리 인덱스는 여전히 동일한 프라이머리 키를 참조하므로, 인덱스 갱신 비용이 줄어듭니다.

          반대로 MyISAM 스토리지 엔진은 클러스터링 인덱스를 지원하지 않습니다. MyISAM에서는 프라이머리 키와 세컨더리 인덱스가 구조적으로 동일하며, 단순히 “유니크 제약이 있는 인덱스”일 뿐입니다. 또한 모든 인덱스가 실제 데이터의 물리적 주소(ROWID)를 직접 저장하기 때문에, 데이터의 삽입이나 삭제로 인해 물리적 위치가 바뀌면 모든 인덱스의 주소를 수정해야 하는 오버헤드가 발생할 수 있습니다. 결국 InnoDB는 프라이머리 키를 논리적 주소로 사용하는 구조를 채택함으로써, 페이지 분할(page split)이나 병합(page merge) 같은 내부 동작에도 불구하고 인덱스 일관성을 유지하고 관리 비용을 최소화합니다.

          그리고, 외래 키 제약 조건은 InnoDB 스토리지 엔진 레벨에서만 지원되는 기능입니다. 따라서 MyISAM이나 MEMORY 엔진에서는 사용할 수 없습니다. InnoDB에서 외래 키를 정의하려면 부모 테이블과 자식 테이블의 해당 컬럼 모두에 인덱스가 생성되어 있어야 합니다. 또한 데이터가 변경될 때마다 부모 또는 자식 테이블에 참조되는 데이터가 존재하는지 확인하는 과정이 필요하므로, 잠금(lock)이 여러 테이블로 전파됩니다. 이 때문에 복잡한 외래 키 관계를 가진 시스템에서는 **데드락(Deadlock)**이 발생할 수 있으므로, 설계 단계에서 외래 키의 존재를 신중히 고려해야 합니다.

          InnoDB는 MVCC(Multi-Version Concurrency Control)를 통해 **잠금을 사용하지 않고도 일관된 읽기(Consistent Read)**를 제공합니다. MVCC의 핵심 목적은 동시에 여러 트랜잭션이 접근하더라도, 각 트랜잭션이 일관된 데이터 상태를 볼 수 있도록 하는 것입니다. 이 기능은 **언두 로그(Undo Log)**를 이용해 구현됩니다.

          ‘멀티 버전(Multi-Version)’이라는 표현은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미입니다. 즉, 어떤 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션은 수정되기 전의 버전(Undo 영역에 저장된 버전)을 읽을 수 있습니다.

          예를 들어, READ_COMMITTED 격리 수준에서 트랜잭션 A가 레코드를 수정하고 아직 COMMIT하지 않았다면, 트랜잭션 B는 변경된 데이터가 아니라 언두 로그에 저장된 변경 이전의 값을 조회합니다. 이처럼 InnoDB는 커밋되지 않은 데이터를 직접 읽지 않으며, 이를 통해 잠금 없는 일관된 읽기를 제공합니다.

          MVCC의 가장 큰 장점은 읽기 작업 시 잠금을 걸지 않는다는 점입니다. 따라서 InnoDB에서는 SELECT 문이 다른 트랜잭션의 쓰기 작업을 기다리지 않고 바로 실행될 수 있습니다. 이는 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 격리 수준에서 모두 적용됩니다.

          다만, 가장 높은 격리 수준인 SERIALIZABLE에서는 일관성을 보장하기 위해 읽기 작업에도 잠금이 걸릴 수 있습니다. 이를 제외하면 InnoDB의 대부분의 읽기 쿼리는 다른 트랜잭션의 변경 작업과 상관없이 동시 실행이 가능합니다. 이 동작 방식은 데이터베이스의 처리량을 극대화하고, 대기 시간을 줄이는 핵심 기술입니다.
          
          또한, InnoDB는 내부적으로 **잠금 대기 목록(Lock Wait-for List)**을 그래프 형태로 관리하여, 트랜잭션 간의 교착 상태(데드락)가 발생했는지를 실시간으로 감시합니다. InnoDB의 데드락 감지 스레드는 주기적으로 이 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아내고, 그중 하나를 자동으로 강제 종료(롤백)시켜 나머지 트랜잭션이 진행될 수 있도록 합니다.

          어떤 트랜잭션을 종료할지는 언두 로그의 크기에 따라 결정되며, Undo 로그 레코드를 더 적게 가진 트랜잭션이 먼저 롤백 대상이 됩니다. 이는 롤백 시 처리해야 할 작업이 적기 때문에, 시스템 부하를 최소화하기 위한 합리적인 정책입니다.

          마지막으로, InnoDB는 ACID 트랜잭션, MVCC, 외래 키 제약, 자동 복구 등 현대적인 RDBMS에서 요구하는 거의 모든 기능을 지원합니다. 장애가 발생하더라도 redo/undo 로그를 이용해 데이터 일관성을 복원할 수 있으며, **버퍼 풀(Buffer Pool)**을 통해 디스크 접근을 최소화하여 성능을 극대화합니다.

          이러한 이유로 InnoDB는, 트랜잭션을 지원하지 않고 Row 단위가 아닌 Table 단위 Lock 밖에 제공하지 않는 MyISAM 이나 MEMORY, 혹은 압축형 스토리지 엔진인 ARCHIVE 에 비해 다양한 기능을 제공하는 안정적인 스토리지 엔진이라고 할 수 있습니다.

          **💬 꼬리질문 1**
            **Q. InnoDB 의 Architecture  에 대해 설명해주세요.**

            위에서 설명드렸듯 InnoDB의 개략적인 구조를 살펴보면, 여러 내부 컴포넌트가 협력하여 트랜잭션 무결성과 성능을 보장합니다. 이 아키텍처는 크게 InnoDB Buffer Pool (데이터와 인덱스를 메모리에 캐싱), Double Write Buffer(데이터 무결성 보장), Undo Log(트랜잭션 롤백 및 격리 수준 유지), Change Buffer(인덱스 비일관성 관리), Redo Log and Log Buffer(데이터 복구), Adaptive Hash Index 등 여러가지로 구성되어 있습니다. 각 구성 요소는 데이터를 안전하게 저장하고, 장애 시 자동으로 복구하며, 동시에 여러 트랜잭션을 처리할 수 있도록 설계되어 있습니다.

            이 내용을 좀 더 자세히 보면, 

            **InnoDB Buffer Pool**
            InnoDB 스토리지 엔진에서 가장 핵심적인 역할을 하는 것은 Buffer Pool입니다. Buffer Pool은 디스크의 데이터 파일이나 인덱스 페이지를 메모리에 캐시해두는 공간으로, 데이터를 빠르게 읽고 쓰기 위해 사용됩니다. 예를 들어, SELECT * FROM table_name WHERE idx = 10; 쿼리를 실행하면 InnoDB는 먼저 Buffer Pool에서 해당 데이터가 있는지 확인합니다. 데이터가 이미 캐시되어 있다면 바로 결과를 반환하고, 없다면 디스크의 ibdata 파일 또는 .ibd 파일에서 데이터를 읽어와 Buffer Pool에 캐시한 후 결과를 반환합니다.
            INSERT 쿼리가 실행될 때도 Buffer Pool은 핵심적인 역할을 합니다. InnoDB는 먼저 Buffer Pool에 해당 데이터 페이지가 있는지 확인하고, 페이지가 존재하면 이를 업데이트하며, 없으면 디스크에서 읽어와 캐시에 반영한 뒤 변경합니다. Buffer Pool에 변경된 데이터는 **더티 페이지(Dirty Page)**로 표시되며, 아직 디스크에 기록되지 않은 상태입니다. 이러한 더티 페이지는 체크포인트 발생 시 일부씩 디스크로 기록되며, Buffer Pool은 쓰기 작업을 지연시켜 일괄 처리할 수 있도록 도와줍니다. 일반적으로 innodb_buffer_pool_size는 장착된 메모리의 50~80% 수준으로 설정하는 것이 권장됩니다.

            **Undo Log**
            Undo 로그는 데이터 변경 시, 변경 이전의 상태를 백업하는 영역입니다. 예를 들어 UPDATE 문이 실행되면 실제 데이터는 변경되지만, 변경 전 데이터는 Undo 영역에 저장됩니다. 이 데이터를 통해 롤백을 수행할 수 있으며, 동시에 **MVCC(Multi-Version Concurrency Control)**를 구현하여 높은 동시성을 제공합니다. 즉, 다른 트랜잭션이 동일한 데이터를 읽을 때, Undo 로그를 참조하여 일관된 시점의 데이터를 반환할 수 있습니다.

            **Change Buffer**
            인덱스 페이지에 직접 쓰기 전에, 변경된 데이터를 임시로 저장하여 여러 변경 사항을 묶어 효율적으로 처리할 수 있도록 돕습니다. 주로 비고유 인덱스의 변경사항을 관리하는 데 사용됩니다.

            **Insert Buffer**
            Insert Buffer는 인덱스 변경 작업의 효율성을 높이기 위해 사용됩니다. 데이터가 INSERT 또는 UPDATE될 때, 데이터 파일뿐만 아니라 인덱스도 함께 변경되어야 합니다. 그러나 인덱스 페이지가 Buffer Pool에 없으면 즉시 디스크에 쓰는 것은 비용이 크므로, Insert Buffer라는 임시 영역에 인덱스 변경 내용을 저장하고 사용자에게 결과를 반환합니다. 이후 백그라운드 스레드가 Insert Buffer와 실제 인덱스를 병합하여 디스크에 반영합니다.

            **Redo Log and Log Buffer**
            Redo 로그는 트랜잭션 실행 시 순차적으로 변경된 내용을 기록하는 파일입니다. 대용량 작업에서 Redo 로그 기록은 성능에 영향을 줄 수 있는데, 이를 보완하기 위해 **로그 버퍼(Log Buffer)**를 사용합니다. 로그 버퍼는 메모리 상에서 Redo 로그를 임시 저장하는 공간이며, 설정값(innodb_log_buffer_size)에 따라 버퍼 크기를 조정할 수 있습니다. 로그 버퍼가 크면 디스크 I/O 횟수를 줄여 성능을 향상시킬 수 있지만, 시스템 다운 시 손실되는 트랜잭션 양이 증가할 수 있고, 버퍼가 작으면 로그 파일 쓰기 부하가 커질 수 있습니다.

            **Table Space**
            InnoDB에서 디스크 스토리지 영역은 시스템 테이블스페이스와 유저 테이블스페이스로 나뉩니다. 시스템 테이블스페이스(기본적으로 ibdata1 파일)는 데이터와 인덱스, 데이터 사전(메타데이터), Undo 로그 등을 포함합니다. 유저 테이블스페이스는 각 테이블마다 .ibd 파일로 존재하며, 데이터와 인덱스를 포함합니다. 기본적으로 innodb_file_per_table 설정이 활성화되어야 유저 테이블스페이스가 생성됩니다. 운영 편의성과 데이터 관리 측면에서 innodb_file_per_table을 활성화하는 것이 권장됩니다.

            **Background Thread**
            InnoDB는 여러 백그라운드 스레드를 통해 Buffer Pool과 Insert Buffer, Undo 로그, Redo 로그 등을 관리합니다. 예를 들어 Insert Buffer Merge 스레드는 Insert Buffer에 임시로 저장된 인덱스 변경 내용을 병합하며, Flush 스레드는 더티 페이지를 체크포인트 시 디스크로 기록합니다. 이러한 백그라운드 작업 덕분에 InnoDB는 디스크 I/O를 효율적으로 관리하고, 트랜잭션 처리 성능과 동시성을 보장할 수 있습니다.

            **Adaptive Hash Index**
            자주 액세스되는 B-tree 페이지에 대한 해시 인덱스를 동적으로 생성하여 검색 속도를 높입니다.

          **💬 꼬리질문 2**
            **Q. MyISAM 과 MEMORY 등 다른 스토리지 엔진에 대해서도 설명해주세요.**

            MyISAM 엔진은 InnoDB보다 구조가 단순하고 처리 속도가 빠르지만, 동시성 제어가 어렵습니다. 과거 MySQL 5.5 이전까지 기본 스토리지 엔진으로 사용되었습니다. MyISAM은 Full-Text 인덱싱, 데이터 압축, GIS(Geographic Information System, 지리정보시스템) 기능 등 여러 유용한 기능을 제공합니다. 다만 트랜잭션을 지원하지 않습니다. MyISAM에는 Key Cache라는 메모리 영역이 존재하는데, 이는 인덱스를 저장하기 위해 미리 할당된 공간으로, 인덱스 디스크 쓰기 작업에 대해서는 부분적으로 버퍼 역할을 수행합니다. 그러나 테이블의 데이터 자체는 캐시되지 않고 항상 디스크를 사용합니다. MyISAM은 Row 단위가 아닌 테이블 단위의 잠금을 제공하며, 읽기와 쓰기를 수행할 때 공유된 읽기 잠금과 배타적 쓰기 잠금을 확보해야 합니다. 동시 삽입 기능을 지원하므로 대량 Insert 작업과 같은 배치 처리에 적합합니다. 따라서 MyISAM은 읽기 전용 또는 읽기 중심의 작업에 적합하며, 주로 데이터 웨어하우스 환경에서 많이 사용됩니다.

            MEMORY 엔진은 데이터를 메모리에 저장하는 스토리지 엔진으로, 디스크 I/O를 거치지 않아 매우 높은 처리 속도를 제공합니다. 이 엔진은 테이블 단위의 잠금을 사용합니다. 데이터를 메모리에 저장하기 때문에 기본적으로 속도가 빠르지만, 서버가 종료되면 데이터가 유실될 가능성이 있습니다. 테이블의 정의는 MySQL 데이터 사전에 저장되며, 디스크에 파일은 생성되지 않습니다. MEMORY 엔진은 중요도가 낮지만 빠른 처리가 필요한 임시 테이블에 주로 사용됩니다. 실제 사용 사례로는 데이터 조회 또는 매핑, 주기적으로 집계되는 데이터의 캐싱, 데이터 분석 시 중간 결과 저장 등이 있습니다.

            ARCHIVE 엔진은 대량의 데이터를 압축하여 저장하는 스토리지 엔진입니다. 데이터가 Insert될 때마다 zlib로 압축되므로 디스크 I/O를 최소화하며, Insert 작업을 빠르게 처리할 수 있습니다. ARCHIVE 엔진은 Insert, Replace, Select 쿼리는 지원하지만 Delete와 Update는 지원하지 않습니다. 잠금 단위는 Row 수준으로 작동합니다. 주로 로그성 데이터나 대량 데이터를 저장하고 읽는 용도로 사용됩니다. ARCHIVE 엔진은 인덱스를 지원하지 않습니다.

            CSV 엔진은 쉼표로 구분된 텍스트 파일 형태로 데이터를 저장하는 스토리지 엔진입니다. CSV 엔진으로 생성된 테이블의 모든 컬럼은 NOT NULL 속성을 가집니다. 서버가 실행되는 동안 데이터베이스 내부와 외부로 파일을 복사할 수 있으며, 대부분의 응용 프로그램과 쉽게 통합될 수 있어 유연성을 제공합니다. 예를 들어, 스프레드시트에서 CSV 파일을 내보내 MySQL 서버의 데이터 디렉터리에 저장하면, 서버는 즉시 이 파일을 읽을 수 있고, CSV 테이블에 데이터를 기록하면 외부 프로그램을 통해 내용을 확인할 수 있습니다.

            FEDERATED 엔진은 별도의 물리적 MySQL 서버를 하나의 논리적 데이터베이스로 연결하는 스토리지 엔진으로, 분산 데이터 환경에서 사용이 권장됩니다. FEDERATED 테이블은 Remote Server와 Local Server로 구성됩니다. Remote Server에는 실제 테이블 정의와 데이터가 존재하며, MyISAM이나 InnoDB 등 원격 서버에서 지원되는 스토리지 엔진을 사용할 수 있습니다. Local Server에는 Remote 테이블과 동일한 구조의 테이블 정의가 필요하며, 스토리지 엔진은 FEDERATED로 구성됩니다. Local Server에는 데이터 파일이 존재하지 않고, 테이블 정의에 Remote 테이블의 연결 정보만 포함되어 있습니다. Local Server에서 FEDERATED 테이블을 쿼리하면 Remote Server의 테이블을 참조하며, Insert, Update, Delete 등의 작업은 Remote Server로 전달되어 실제 데이터에 반영되거나 해당 Row를 반환합니다.
          
          **❓ IT 용어**
          🖊️ **Storage Engine:** 데이터베이스에서 데이터를 실제로 어떻게 저장하고, 읽고, 쓰고, 인덱싱하고, 트랜잭션을 관리할지를 담당하는 저수준 모듈.
          🖊️ **Multi-Version Concurrency Control:** **언두 로그(Undo Log)**와 **트랜잭션 ID(Transaction ID)**를 사용하여, 동시에 여러 트랜잭션이 데이터에 접근해도 충돌 없이 읽기와 쓰기를 가능하게 하는 InnoDB의 핵심 기능
          🖊️ **Page Split:** InnoDB에서 인덱스는 B+Tree 구조로 관리되며, 트리의 균형을 유지하기 위해 **페이지 분할(Page Split)**과 페이지 병합(Page Merge) 작업이 수행됨. **Page Split(페이지 분할)**은 인덱스 페이지가 꽉 차서 더 이상 새로운 데이터를 저장할 수 없을 때 발생함. 이때 InnoDB는 기존 페이지를 두 개의 페이지로 나누고(split), 정렬 순서를 유지하기 위해 중간 키를 상위 노드로 승격시킴. 이러한 분할은 B-Tree의 균형을 유지하고 일정한 검색 성능을 보장하기 위한 핵심 동작임. 다만, 페이지 분할은 새로운 페이지를 할당하고 일부 데이터를 이동해야 하므로 디스크 I/O와 CPU 부하가 증가함. 따라서 무작위 삽입(Random Insert)이 빈번할 경우 Split이 자주 발생하며, 인덱스 단편화(fragmentation)가 심화될 수 있음. 반대로 **Page Merge(페이지 병합)**은 인덱스 페이지의 데이터가 너무 적어져 공간 낭비가 발생할 때 수행됨. InnoDB는 인접한 두 페이지를 하나로 합쳐 저장 공간을 효율적으로 사용하고 트리의 균형을 복원함. 병합은 Split의 반대 동작으로, 데이터 삭제가 빈번한 테이블에서 자주 발생함. 결과적으로, Page Split과 Page Merge는 B-Tree 인덱스의 균형을 유지하고 효율적인 검색 성능을 보장하기 위한 자동 조정 메커니즘이라 할 수 있음.
        `,
      },
      {
        title: "Q. Clustered Index & non- Clustered Index",
        date: "2025.10.09",
        detail: `
          
        `
      }
    ]
  },
]
